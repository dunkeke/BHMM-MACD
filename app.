import streamlit as st
import numpy as np
import pandas as pd
import yfinance as yf
from hmmlearn.hmm import GaussianHMM
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import warnings

# å¿½ç•¥éƒ¨åˆ† sklearn è­¦å‘Š
warnings.filterwarnings("ignore")

# ==========================================
# PART 1: æ ¸å¿ƒç­–ç•¥ç±» (Strategies)
# ==========================================

class HMMStandardStrategy:
    """ç»å…¸ HMM ç­–ç•¥"""
    def __init__(self, n_components=3, iter_num=1000, window_size=21):
        self.n_components = n_components
        self.iter_num = iter_num
        self.window_size = window_size

    def generate_signals(self, df):
        df = df.copy()
        df['Log_Ret'] = np.log(df['Close'] / df['Close'].shift(1))
        df['Volatility'] = df['Log_Ret'].rolling(window=self.window_size).std()
        df.dropna(inplace=True)
        if len(df) < 100: return df
        X = df[['Log_Ret', 'Volatility']].values * 100.0
        try:
            model = GaussianHMM(n_components=self.n_components, covariance_type="full", n_iter=self.iter_num, random_state=42, tol=0.01, min_covar=0.01)
            model.fit(X)
        except: return df
        hidden_states = model.predict(X)
        state_vol_means = [X[hidden_states == i, 1].mean() for i in range(self.n_components)]
        sorted_stats = sorted(list(enumerate(state_vol_means)), key=lambda x: x[1])
        mapping = {old: new for new, (old, _) in enumerate(sorted_stats)}
        df['Regime'] = np.array([mapping[s] for s in hidden_states])
        df['Signal'] = 0
        df.loc[df['Regime'] == 0, 'Signal'] = 1
        df.loc[df['Regime'] == self.n_components-1, 'Signal'] = -1
        return df

class HMMAdaptiveStrategy:
    """è‡ªé€‚åº”è´å¶æ–¯ç­–ç•¥"""
    def __init__(self, n_components=3, iter_num=1000, window_size=21):
        self.n_components = n_components
        self.iter_num = iter_num
        self.window_size = window_size

    def generate_signals(self, df):
        df = df.copy()
        df['Log_Ret'] = np.log(df['Close'] / df['Close'].shift(1))
        df['Volatility'] = df['Log_Ret'].rolling(window=self.window_size).std()
        df.dropna(inplace=True)
        if len(df) < 100: return df
        X = df[['Log_Ret', 'Volatility']].values * 100.0
        try:
            model = GaussianHMM(n_components=self.n_components, covariance_type="full", n_iter=self.iter_num, random_state=42, tol=0.01, min_covar=0.01)
            model.fit(X)
        except: return df
        hidden_states = model.predict(X)
        state_vol_means = [X[hidden_states == i, 1].mean() for i in range(self.n_components)]
        sorted_stats = sorted(list(enumerate(state_vol_means)), key=lambda x: x[1])
        mapping = {old: new for new, (old, _) in enumerate(sorted_stats)}
        posterior_probs = model.predict_proba(X)
        sorted_probs = np.zeros_like(posterior_probs)
        for old_i, new_i in mapping.items():
            sorted_probs[:, new_i] = posterior_probs[:, old_i]
        df['Regime'] = np.array([mapping[s] for s in hidden_states])
        for i in range(self.n_components):
            df[f'Prob_S{i}'] = sorted_probs[:, i]
        state_means = []
        for i in range(self.n_components):
            state_means.append(df[df['Regime'] == i]['Log_Ret'].mean())
        new_transmat = np.zeros_like(model.transmat_)
        for i in range(self.n_components):
            for j in range(self.n_components):
                new_transmat[mapping[i], mapping[j]] = model.transmat_[i, j]
        next_probs = np.dot(sorted_probs, new_transmat)
        df['Bayes_Exp_Ret'] = np.dot(next_probs, state_means)
        threshold = 0.0003
        df['Signal'] = 0
        df.loc[df['Bayes_Exp_Ret'] > threshold, 'Signal'] = 1
        df.loc[df['Bayes_Exp_Ret'] < -threshold, 'Signal'] = -1
        return df

class HMM_MACD_Strategy:
    """
    [æ–°å¢] HMM + 4H MACD è´å¶æ–¯å…±æŒ¯ç­–ç•¥
    é€»è¾‘ï¼š
    1. è®¡ç®— 4å°æ—¶ MACD ä½œä¸ºâ€œæŠ€æœ¯é¢ä¼¼ç„¶å‡½æ•°â€ (Likelihood)
    2. è®¡ç®— æ—¥çº¿ HMM ä½œä¸ºâ€œç»“æ„é¢å…ˆéªŒæ¦‚ç‡â€ (Prior)
    3. è´å¶æ–¯æ›´æ–° -> åéªŒæ¦‚ç‡ -> ä¿¡å·
    """
    def __init__(self, n_components=3, iter_num=1000, window_size=21):
        self.n_components = n_components
        self.iter_num = iter_num
        self.window_size = window_size

    def calculate_macd(self, df_prices):
        """è®¡ç®—æ ‡å‡† MACD (12, 26, 9)"""
        exp1 = df_prices.ewm(span=12, adjust=False).mean()
        exp2 = df_prices.ewm(span=26, adjust=False).mean()
        macd = exp1 - exp2
        signal = macd.ewm(span=9, adjust=False).mean()
        hist = macd - signal
        return macd, signal, hist

    def get_4h_macd_signal(self, ticker):
        """è·å–4å°æ—¶çº§åˆ«æ•°æ®å¹¶è®¡ç®—MACD"""
        try:
            # yfinance é™åˆ¶ï¼š1hæ•°æ®åªèƒ½å–730å¤©ã€‚æˆ‘ä»¬å–æœ€è¿‘60å¤©çš„é«˜é¢‘æ•°æ®æ¥æ¨¡æ‹Ÿè¿‘æœŸä¿¡å·
            # å¯¹äºæ›´ä¹…è¿œçš„å†å²å›æµ‹ï¼Œè¿™é‡Œç®€åŒ–ä½¿ç”¨æ—¥çº¿MACDæ¨¡æ‹Ÿï¼Œæˆ–éœ€ä»˜è´¹æ•°æ®æº
            # è¿™é‡Œä¸ºäº†æ¼”ç¤º"å½“å‰çŠ¶æ€"ï¼Œæˆ‘ä»¬å–æœ€è¿‘60å¤©1hæ•°æ®å¹¶é‡é‡‡æ ·
            df_1h = yf.download(ticker, period="60d", interval="1h", progress=False, auto_adjust=True)
            if isinstance(df_1h.columns, pd.MultiIndex): df_1h.columns = df_1h.columns.get_level_values(0)
            
            if len(df_1h) < 24: return None

            # é‡é‡‡æ ·ä¸º 4å°æ—¶ Kçº¿
            df_4h = df_1h['Close'].resample('4h').ohlc() # è¿™é‡Œçš„4hæ˜¯å›ºå®šæ—¶é—´çª—å£
            df_4h.dropna(inplace=True)
            close_4h = df_4h['close'] # æ³¨æ„æ˜¯å°å†™close

            # è®¡ç®— MACD
            macd, signal, hist = self.calculate_macd(close_4h)
            
            # å¯¹é½åˆ°æ—¥çº¿ (å–å½“å¤©çš„æœ€åä¸€ä¸ª4hä¿¡å·ä½œä¸ºæ—¥çº¿ä¿¡å·çš„ä¿®æ­£)
            # è¿™æ˜¯ä¸€ä¸ªé™é‡‡æ ·è¿‡ç¨‹
            macd_daily = hist.resample('1D').last().fillna(method='ffill')
            
            return macd_daily
        except:
            return None

    def generate_signals(self, df, ticker_symbol=None):
        # 1. åŸºç¡€ HMM è®¡ç®— (Prior)
        df = HMMAdaptiveStrategy(self.n_components, self.iter_num, self.window_size).generate_signals(df)
        
        # ä¿å­˜åŸå§‹ HMM ä¿¡å·ç”¨äºå¯¹æ¯”
        df['Signal_HMM_Only'] = df['Signal']
        df['Prob_S0_Prior'] = df.get('Prob_S0', 0.33) # å‡è®¾ S0 æ˜¯çœ‹æ¶¨çŠ¶æ€
        df['Prob_S2_Prior'] = df.get('Prob_S2', 0.33) # å‡è®¾ S2 æ˜¯çœ‹è·ŒçŠ¶æ€
        
        # 2. è·å– 4H MACD è¯æ® (Evidence)
        if ticker_symbol:
            macd_series = self.get_4h_macd_signal(ticker_symbol)
            if macd_series is not None:
                # å°† MACD æ•°æ®åˆå¹¶åˆ°ä¸» df
                df = df.join(macd_series.rename('MACD_Hist_4H'), how='left')
                df['MACD_Hist_4H'] = df['MACD_Hist_4H'].fillna(method='ffill').fillna(0)
            else:
                df['MACD_Hist_4H'] = 0
        else:
            df['MACD_Hist_4H'] = 0

        # 3. è´å¶æ–¯æ›´æ–° (Bayesian Update)
        # ä¼¼ç„¶å‡½æ•° P(MACD | State): 
        # - å¦‚æœ MACD é‡‘å‰ (Hist > 0)ï¼Œæ›´æ”¯æŒ State 0 (ç‰›)
        # - å¦‚æœ MACD æ­»å‰ (Hist < 0)ï¼Œæ›´æ”¯æŒ State 2 (ç†Š)
        
        # ä¼¼ç„¶å¼ºåº¦å› å­ (MACD Influence)
        # å½’ä¸€åŒ– MACD ç›´æ–¹å›¾ï¼Œä½¿å…¶åœ¨ -1 åˆ° 1 ä¹‹é—´ (ç²—ç•¥ä¼°è®¡)
        macd_norm = np.clip(df['MACD_Hist_4H'] / (df['Close'] * 0.01 + 1e-6), -1, 1) * 2.0 # æ”¾å¤§ç³»æ•°
        
        # è®¡ç®—åéªŒæ¦‚ç‡
        # P(S0|MACD) âˆ P(S0) * exp(macd_norm)  (MACDè¶Šæ­£ï¼ŒS0æ¦‚ç‡è¶Šå¤§)
        # P(S2|MACD) âˆ P(S2) * exp(-macd_norm) (MACDè¶Šè´Ÿï¼ŒS2æ¦‚ç‡è¶Šå¤§)
        # P(S1|MACD) âˆ P(S1) * 1             (MACDå¯¹éœ‡è¡çŠ¶æ€æ— ç‰¹åˆ«åå¥½)
        
        likelihood_0 = np.exp(macd_norm)
        likelihood_1 = np.ones_like(macd_norm)
        likelihood_2 = np.exp(-macd_norm)
        
        df['Prob_S0_Post'] = df['Prob_S0_Prior'] * likelihood_0
        df['Prob_S1_Post'] = df.get('Prob_S1', 0.33) * likelihood_1
        df['Prob_S2_Post'] = df['Prob_S2_Prior'] * likelihood_2
        
        # å½’ä¸€åŒ–
        total_prob = df['Prob_S0_Post'] + df['Prob_S1_Post'] + df['Prob_S2_Post']
        df['Prob_S0_Post'] /= total_prob
        df['Prob_S2_Post'] /= total_prob
        
        # 4. æ›´æ–°ä¿¡å·
        # å¦‚æœåéªŒ S0 æ¦‚ç‡ > 50% ä¸” MACD > 0 -> Strong Buy
        # å¦‚æœåéªŒ S2 æ¦‚ç‡ > 50% ä¸” MACD < 0 -> Strong Sell
        # å¦åˆ™ -> Wait
        
        df['Signal'] = 0 # é‡ç½®ä¿¡å·
        
        # æ¿€è¿›ç­–ç•¥ï¼šåªè¦æ¦‚ç‡ä¼˜åŠ¿å‡ºç°å³å¼€ä»“
        # State 0 å ä¼˜ + MACD ç¡®è®¤
        df.loc[(df['Prob_S0_Post'] > 0.4) & (df['MACD_Hist_4H'] > 0), 'Signal'] = 1
        
        # State 2 å ä¼˜ + MACD ç¡®è®¤
        df.loc[(df['Prob_S2_Post'] > 0.4) & (df['MACD_Hist_4H'] < 0), 'Signal'] = -1
        
        return df

class SpreadArbStrategy:
    """ç»Ÿè®¡å¥—åˆ©ç­–ç•¥"""
    def __init__(self, window_size=20, z_threshold=1.5):
        self.window_size = window_size
        self.z_threshold = z_threshold

    def generate_signals(self, df_a, df_b):
        data = pd.DataFrame(index=df_a.index)
        data['Price_A'] = df_a['Close']
        data['Price_B'] = df_b['Close']
        data.dropna(inplace=True)
        if len(data) < 50: return data
        data['Spread'] = data['Price_A'] - data['Price_B']
        data['Spread_Mean'] = data['Spread'].rolling(self.window_size).mean()
        data['Spread_Std'] = data['Spread'].rolling(self.window_size).std()
        data['Z_Score'] = (data['Spread'] - data['Spread_Mean']) / (data['Spread_Std'] + 1e-8)
        data['Signal'] = 0
        data.loc[data['Z_Score'] > self.z_threshold, 'Signal'] = -1
        data.loc[data['Z_Score'] < -self.z_threshold, 'Signal'] = 1
        ret_a = np.log(data['Price_A'] / data['Price_A'].shift(1)).fillna(0)
        ret_b = np.log(data['Price_B'] / data['Price_B'].shift(1)).fillna(0)
        data['Spread_Ret_Raw'] = ret_a - ret_b
        return data

# ==========================================
# PART 2: å›æµ‹å¼•æ“
# ==========================================

class BacktestEngine:
    def __init__(self, initial_capital=100000, transaction_cost=0.0002):
        self.initial_capital = initial_capital
        self.cost = transaction_cost

    def run(self, df, ret_col='Log_Ret'):
        df = df.copy()
        df['Position'] = df['Signal'].shift(1).fillna(0)
        trades = df['Position'].diff().abs().fillna(0)
        fees = trades * self.cost
        df[ret_col] = df[ret_col].fillna(0)
        df['Strategy_Ret'] = (df['Position'] * df[ret_col]) - fees
        df['Equity_Curve'] = self.initial_capital * (1 + df['Strategy_Ret']).cumprod()
        df['Benchmark_Curve'] = self.initial_capital * (1 + df[ret_col]).cumprod()
        return df

    def calculate_metrics(self, df):
        if df.empty or 'Equity_Curve' not in df.columns or len(df) < 2: return self._empty_metrics()
        equity = df['Equity_Curve']
        ret = df['Strategy_Ret']
        start_val = equity.iloc[0] if equity.iloc[0] > 0 else self.initial_capital
        total_ret = (equity.iloc[-1] / start_val) - 1
        time_span = df.index[-1] - df.index[0]
        days = time_span.days + (time_span.seconds / 86400)
        cagr = (1 + total_ret) ** (365 / days) - 1 if days > 0.5 else 0
        vol = ret.std() * np.sqrt(252)
        sharpe = (ret.mean() * 252) / (vol + 1e-8) if vol > 0 else 0
        roll_max = equity.cummax()
        dd = (equity - roll_max) / (roll_max + 1e-8)
        max_dd = dd.min()
        active_days = df[df['Position'] != 0]
        win_rate = len(active_days[active_days['Strategy_Ret'] > 0]) / len(active_days) if len(active_days) > 0 else 0
        return {"Total Return": f"{total_ret*100:.2f}%", "CAGR": f"{cagr*100:.2f}%", "Sharpe Ratio": f"{sharpe:.2f}", "Max Drawdown": f"{max_dd*100:.2f}%", "Win Rate": f"{win_rate*100:.1f}%"}
        
    def _empty_metrics(self):
        return {k: "N/A" for k in ["Total Return", "CAGR", "Sharpe Ratio", "Max Drawdown", "Win Rate"]}

# ==========================================
# PART 3: ä¿¡å·è§£è¯»ä¸å±•ç¤º
# ==========================================

def display_signal_panel(df, strategy_type):
    last = df.iloc[-1]
    sig = last['Signal']
    st.markdown("### ğŸš¦ å®æ—¶äº¤æ˜“ä¿¡å·é©¾é©¶èˆ±")
    col_sig, col_reason = st.columns([1, 2])
    
    with col_sig:
        if sig == 1: st.success("## ğŸŸ¢ å¼ºåŠ›åšå¤š\n**LONG SIGNAL**")
        elif sig == -1: st.error("## ğŸ”´ å¼ºåŠ›å–å‡º\n**SHORT SIGNAL**")
        else: st.warning("## âšª ç©ºä»“è§‚æœ›\n**WAIT / CASH**")
            
    with col_reason:
        st.markdown("#### ğŸ¤– ç­–ç•¥é€»è¾‘åˆ†æ")
        if "MACD" in strategy_type:
            prob_0_post = last.get('Prob_S0_Post', 0) * 100
            prob_2_post = last.get('Prob_S2_Post', 0) * 100
            macd_val = last.get('MACD_Hist_4H', 0)
            
            macd_status = "ğŸŸ¢ é‡‘å‰/å‘ä¸Š" if macd_val > 0 else "ğŸ”´ æ­»å‰/å‘ä¸‹"
            
            msg = f"""
            - **HMM å®è§‚æ¦‚ç‡ (åéªŒ)**: ç‰›(S0): **{prob_0_post:.1f}%** | ç†Š(S2): **{prob_2_post:.1f}%**
            - **4H æŠ€æœ¯é¢å…±æŒ¯**: MACD Histogram = {macd_val:.3f} ({macd_status})
            """
            if sig == 1: msg += "\n\nğŸ’¡ **ç»“è®º**: å®è§‚ä½æ³¢åŠ¨ + 4Hçº§åˆ«MACDé‡‘å‰å…±æŒ¯ï¼Œ**å¼ºçƒˆçœ‹å¤š**ã€‚"
            elif sig == -1: msg += "\n\nğŸ’¡ **ç»“è®º**: å®è§‚é«˜æ³¢åŠ¨ + 4Hçº§åˆ«MACDæ­»å‰å…±æŒ¯ï¼Œ**å¼ºçƒˆçœ‹ç©º**ã€‚"
            else: msg += "\n\nğŸ’¡ **ç»“è®º**: HMM ä¸ MACD ä¿¡å·èƒŒç¦»æˆ–åŠ¨èƒ½ä¸è¶³ï¼Œå»ºè®®**è§‚æœ›**ã€‚"
            st.info(msg)
            
        elif "è‡ªé€‚åº”" in strategy_type:
            prob_0 = last.get('Prob_S0', 0) * 100
            exp_ret = last.get('Bayes_Exp_Ret', 0) 
            msg = f"- **å½“å‰ä½“åˆ¶**: State {int(last['Regime'])}\n- **è´å¶æ–¯æœŸæœ›**: {exp_ret*100:.4f}%"
            st.info(msg)
        elif "å¥—åˆ©" in strategy_type:
            z_score = last.get('Z_Score', 0)
            msg = f"- **Z-Score**: {z_score:.2f} Ïƒ"
            st.info(msg)
        else:
            st.info(f"- **å½“å‰ä½“åˆ¶**: State {int(last['Regime'])}")

# ==========================================
# PART 4: Streamlit UI
# ==========================================

st.set_page_config(page_title="èƒ½æºé‡åŒ–ç»ˆç«¯ Pro Max", layout="wide", page_icon="âš¡")
st.title("âš¡ Energy Quant Lab: HMM + MACD Resonance System")
st.markdown("### è´å¶æ–¯åéªŒå¢å¼ºç‰ˆï¼šæ—¥çº¿ HMM å åŠ  4H MACD ä¿¡å·")

st.sidebar.header("âš™ï¸ ç­–ç•¥æ§åˆ¶å°")
strategy_type = st.sidebar.selectbox(
    "é€‰æ‹©ç­–ç•¥ç±»å‹",
    ["HMM + 4H MACD è´å¶æ–¯å…±æŒ¯ (New!)", "HMM è‡ªé€‚åº”è´å¶æ–¯ (Adaptive)", "HMM ç»å…¸æ¨¡å‹ (Standard)", "ç»Ÿè®¡å¥—åˆ© (Pairs Trading)"]
)

tickers = {"Brent Crude": "BZ=F", "WTI Crude": "CL=F", "Natural Gas (HH)": "NG=F", "Dutch TTF": "TTF=F"}

if "å¥—åˆ©" in strategy_type:
    col1, col2 = st.sidebar.columns(2)
    asset_a = col1.selectbox("èµ„äº§ A (Long)", list(tickers.keys()), index=0)
    asset_b = col2.selectbox("èµ„äº§ B (Short)", list(tickers.keys()), index=1)
    ticker = f"{asset_a} vs {asset_b}"
else:
    asset = st.sidebar.selectbox("é€‰æ‹©äº¤æ˜“æ ‡çš„", list(tickers.keys()))
    ticker = tickers[asset]

start_date = st.sidebar.date_input("å›æµ‹å¼€å§‹", datetime.now() - timedelta(days=365*2))
end_date = st.sidebar.date_input("å›æµ‹ç»“æŸ", datetime.now())

if st.sidebar.button("ğŸš€ è¿è¡Œåˆ†æ", type="primary"):
    engine = BacktestEngine(initial_capital=100000, transaction_cost=0.0002)
    
    with st.spinner(f"æ­£åœ¨è®¡ç®— {ticker} çš„é‡åŒ–ä¿¡å·..."):
        try:
            if "å¥—åˆ©" in strategy_type:
                df_a = yf.download(tickers[asset_a], start=start_date, end=end_date, progress=False, auto_adjust=True)
                df_b = yf.download(tickers[asset_b], start=start_date, end=end_date, progress=False, auto_adjust=True)
                if isinstance(df_a.columns, pd.MultiIndex): df_a.columns = df_a.columns.get_level_values(0)
                if isinstance(df_b.columns, pd.MultiIndex): df_b.columns = df_b.columns.get_level_values(0)

                if df_a.empty or df_b.empty:
                    st.error("æ•°æ®ä¸è¶³ã€‚")
                else:
                    strat = SpreadArbStrategy()
                    df_res = strat.generate_signals(df_a, df_b)
                    if len(df_res) > 0:
                        display_signal_panel(df_res, strategy_type)
                        st.divider()
                        df_bt = engine.run(df_res, ret_col='Spread_Ret_Raw')
                        metrics = engine.calculate_metrics(df_bt)
                        kpi1, kpi2, kpi3, kpi4, kpi5 = st.columns(5)
                        kpi1.metric("æ€»å›æŠ¥", metrics['Total Return'])
                        kpi2.metric("å¹´åŒ–æ”¶ç›Š", metrics['CAGR'])
                        kpi3.metric("å¤æ™®æ¯”ç‡", metrics['Sharpe Ratio'])
                        kpi4.metric("æœ€å¤§å›æ’¤", metrics['Max Drawdown'])
                        kpi5.metric("èƒœç‡", metrics['Win Rate'])
                        
                        fig = go.Figure()
                        fig.add_trace(go.Scatter(x=df_bt.index, y=df_bt['Equity_Curve'], name="Strategy Equity", line=dict(color='cyan', width=2)))
                        st.plotly_chart(fig, use_container_width=True)
            else:
                df = yf.download(tickers[asset], start=start_date, end=end_date, progress=False, auto_adjust=True)
                if isinstance(df.columns, pd.MultiIndex): df.columns = df.columns.get_level_values(0)
                
                if df.empty:
                    st.error("æ•°æ®è·å–å¤±è´¥ã€‚")
                else:
                    if "MACD" in strategy_type:
                        strat = HMM_MACD_Strategy()
                        # éœ€è¦ä¼ å…¥ ticker symbol æ¥è·å– 4H æ•°æ®
                        df_res = strat.generate_signals(df, ticker_symbol=tickers[asset])
                    elif "è‡ªé€‚åº”" in strategy_type:
                        strat = HMMAdaptiveStrategy()
                        df_res = strat.generate_signals(df)
                    else:
                        strat = HMMStandardStrategy()
                        df_res = strat.generate_signals(df)
                    
                    if 'Signal' in df_res.columns:
                        display_signal_panel(df_res, strategy_type)
                        st.divider()
                        df_bt = engine.run(df_res, ret_col='Log_Ret')
                        metrics = engine.calculate_metrics(df_bt)
                        kpi1, kpi2, kpi3, kpi4, kpi5 = st.columns(5)
                        kpi1.metric("æ€»å›æŠ¥", metrics['Total Return'])
                        kpi2.metric("å¹´åŒ–æ”¶ç›Š", metrics['CAGR'])
                        kpi3.metric("å¤æ™®æ¯”ç‡", metrics['Sharpe Ratio'])
                        kpi4.metric("æœ€å¤§å›æ’¤", metrics['Max Drawdown'])
                        kpi5.metric("èƒœç‡", metrics['Win Rate'])
                        
                        tab1, tab2 = st.tabs(["ğŸ“ˆ ä¿¡å·ä¸å‡€å€¼", "ğŸ”¬ æ•°æ®ç»†èŠ‚"])
                        with tab1:
                            fig = make_subplots(rows=2, cols=1, shared_xaxes=True, row_heights=[0.6, 0.4], vertical_spacing=0.05)
                            
                            # ä¸»å›¾ï¼šä»·æ ¼ + ä¿¡å·
                            fig.add_trace(go.Scatter(x=df_bt.index, y=df_bt['Close'], name="Price", line=dict(color='white', width=1)), row=1, col=1)
                            buy_sig = df_bt[df_bt['Signal'] == 1]
                            sell_sig = df_bt[df_bt['Signal'] == -1]
                            fig.add_trace(go.Scatter(x=buy_sig.index, y=buy_sig['Close'], mode='markers', marker=dict(symbol='triangle-up', color='lime', size=10), name='Buy'), row=1, col=1)
                            fig.add_trace(go.Scatter(x=sell_sig.index, y=sell_sig['Close'], mode='markers', marker=dict(symbol='triangle-down', color='red', size=10), name='Sell'), row=1, col=1)
                            
                            # å‰¯å›¾ï¼šMACD (å¦‚æœæ˜¯ MACD ç­–ç•¥) æˆ– å‡€å€¼
                            if "MACD" in strategy_type and 'MACD_Hist_4H' in df_bt.columns:
                                # ç»˜åˆ¶ MACD æŸ±çŠ¶å›¾
                                colors = df_bt['MACD_Hist_4H'].apply(lambda x: '#00ff00' if x>0 else '#ff0000')
                                fig.add_trace(go.Bar(x=df_bt.index, y=df_bt['MACD_Hist_4H'], name="4H MACD Hist", marker_color=colors), row=2, col=1)
                                fig.update_yaxes(title_text="MACD (4H)", row=2, col=1)
                            else:
                                fig.add_trace(go.Scatter(x=df_bt.index, y=df_bt['Equity_Curve'], name="Strategy Equity", line=dict(color='cyan', width=2)), row=2, col=1)
                                fig.update_yaxes(title_text="Equity", row=2, col=1)
                                
                            fig.update_layout(height=600, template="plotly_dark", title="Technical Resonance Chart")
                            st.plotly_chart(fig, use_container_width=True)
                            
                        with tab2:
                            st.dataframe(df_bt.tail(100).sort_index(ascending=False))
                    else:
                        st.warning("ä¿¡å·ç”Ÿæˆå¤±è´¥ã€‚")

        except Exception as e:
            st.error(f"è¿è¡Œå‡ºé”™: {e}")
